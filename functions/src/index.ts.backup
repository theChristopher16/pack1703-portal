import * as functions from 'firebase-functions/v1';
import * as admin from 'firebase-admin';
// import { secretManagerService } from './secretManagerService'; // Temporarily disabled due to Node.js version compatibility
// Import user approval functions
import { createPendingUser, approveUser, getPendingUsers, getAuditLogs } from './userApproval';
import { setAdminClaims } from './setAdminClaims';
import { testAuth } from './simpleTest';
const Imap = require('node-imap');

// Initialize Firebase Admin
admin.initializeApp();

// Get Firestore instance
const db = admin.firestore();

// Get Auth instance
const auth = admin.auth();

// Helper function to get timestamp (works in both emulator and production)
function getTimestamp(): any {
  try {
    // Try to use Firebase Timestamp if available
    if (admin.firestore.Timestamp && admin.firestore.Timestamp.now) {
      return admin.firestore.Timestamp.now();
    }
    // Fallback to Date object
    return new Date();
  } catch (error) {
    // Final fallback to ISO string
    return new Date().toISOString();
  }
}

// Types for our data
interface RSVPSubmission {
  eventId: string;
  familyName: string;
  email: string;
  phone?: string;
  attendees: Array<{
    name: string;
    age: number;
    den?: string;
    isAdult: boolean;
  }>;
  dietaryRestrictions?: string;
  specialNeeds?: string;
  notes?: string;
  ipHash: string;
  userAgent: string;
  timestamp: admin.firestore.Timestamp;
}

interface FeedbackSubmission {
  category: string;
  rating: number;
  title: string;
  message: string;
  contactEmail?: string;
  contactName?: string;
  eventId?: string;
  ipHash: string;
  userAgent: string;
  timestamp: admin.firestore.Timestamp;
}

interface VolunteerSignup {
  volunteerNeedId: string;
  volunteerName: string;
  email: string;
  phone?: string;
  age: number;
  skills: string[];
  availability: string;
  experience: string;
  specialNeeds?: string;
  emergencyContact?: string;
  ipHash: string;
  userAgent: string;
  timestamp: admin.firestore.Timestamp;
}

interface Event {
  id: string;
  title: string;
  description: string;
  startDate: admin.firestore.Timestamp;
  endDate: admin.firestore.Timestamp;
  location: string;
  maxCapacity?: number;
  currentRSVPs: number;
  category: string;
  denTags: string[];
  season: string;
}

// Location interface (ready for future use)
// interface Location {
//   id: string;
//   name: string;
//   address: string;
//   coordinates: {
//     latitude: number;
//     longitude: number;
//   };
//   description: string;
//   category: string;
//   notesPrivate?: string;
// }

// Rate limiting helper
const rateLimiter = new Map<string, { count: number; resetTime: number }>();

function checkRateLimit(ipHash: string, endpoint: string, limit: number, windowMs: number): boolean {
  const key = `${ipHash}:${endpoint}`;
  const now = Date.now();
  
  if (!rateLimiter.has(key) || now > rateLimiter.get(key)!.resetTime) {
    rateLimiter.set(key, { count: 1, resetTime: now + windowMs });
    return true;
  }
  
  const entry = rateLimiter.get(key)!;
  if (entry.count >= limit) {
    return false;
  }
  
  entry.count++;
  return true;
}

// Input validation helpers
function validateEmail(email: string): boolean {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
}

function sanitizeInput(input: string): string {
  // Basic HTML tag removal and length limiting
  return input
    .replace(/<[^>]*>/g, '')
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .substring(0, 1000);
}

// 1. Submit RSVP Function
// Temporarily commented out for deployment
/*
export const submitRSVP = functions.https.onCall(async (data: RSVPSubmission, context: functions.https.CallableContext) => {
  try {
    // Check App Check (required for production)
    if (process.env.FUNCTIONS_EMULATOR !== 'true' && !context.app) {
      throw new functions.https.HttpsError('unauthenticated', 'App Check verification required');
    }

    // Rate limiting (5 submissions per hour per IP)
    if (!checkRateLimit(data.ipHash, 'rsvp', 5, 60 * 60 * 1000)) {
      throw new functions.https.HttpsError('resource-exhausted', 'Rate limit exceeded');
    }

    // Validate required fields
    if (!data.eventId || !data.familyName || !data.email || !data.attendees || data.attendees.length === 0) {
      throw new functions.https.HttpsError('invalid-argument', 'Missing required fields');
    }

    // Validate email
    if (!validateEmail(data.email)) {
      throw new functions.https.HttpsError('invalid-argument', 'Invalid email format');
    }

    // Sanitize inputs
    const sanitizedData: RSVPSubmission = {
      ...data,
      familyName: sanitizeInput(data.familyName),
      notes: data.notes ? sanitizeInput(data.notes) : undefined,
      dietaryRestrictions: data.dietaryRestrictions ? sanitizeInput(data.dietaryRestrictions) : undefined,
      specialNeeds: data.specialNeeds ? sanitizeInput(data.specialNeeds) : undefined,
      timestamp: getTimestamp()
    };

    // Check event capacity
    const eventRef = db.collection('events').doc(data.eventId);
    const eventDoc = await eventRef.get();
    
    if (!eventDoc.exists) {
      throw new functions.https.HttpsError('not-found', 'Event not found');
    }

    const event = eventDoc.data() as Event;
    if (event.maxCapacity && event.currentRSVPs + data.attendees.length > event.maxCapacity) {
      throw new functions.https.HttpsError('resource-exhausted', 'Event is at capacity');
    }

    // Store RSVP submission
    const submissionData: any = {
      type: 'rsvp',
      eventId: sanitizedData.eventId,
      familyName: sanitizedData.familyName,
      email: sanitizedData.email,
      attendees: sanitizedData.attendees,
      ipHash: sanitizedData.ipHash,
      userAgent: sanitizedData.userAgent,
      timestamp: sanitizedData.timestamp,
      status: 'pending'
    };
    
    // Add optional fields only if they exist
    if (sanitizedData.phone) submissionData.phone = sanitizedData.phone;
    if (sanitizedData.notes) submissionData.notes = sanitizedData.notes;
    if (sanitizedData.dietaryRestrictions) submissionData.dietaryRestrictions = sanitizedData.dietaryRestrictions;
    if (sanitizedData.specialNeeds) submissionData.specialNeeds = sanitizedData.specialNeeds;

    const submissionRef = await db.collection('submissions').add(submissionData);

    // Update event RSVP count
    await eventRef.update({
      currentRSVPs: event.currentRSVPs + data.attendees.length
    });

    // Log analytics event
    await db.collection('analytics').add({
      type: 'rsvp_submission',
      eventId: data.eventId,
      attendees: data.attendees.length,
      timestamp: getTimestamp(),
      ipHash: data.ipHash
    });

    return {
      success: true,
      submissionId: submissionRef.id,
      message: 'RSVP submitted successfully'
    };

  } catch (error) {
    console.error('RSVP submission error:', error);
    throw new functions.https.HttpsError('internal', 'Failed to submit RSVP');
  }
});

// 2. Submit Feedback Function
export const submitFeedback = functions.https.onCall(async (data: FeedbackSubmission, context: functions.https.CallableContext) => {
  try {
    // Check App Check (required for production)
    if (process.env.FUNCTIONS_EMULATOR !== 'true' && !context.app) {
      throw new functions.https.HttpsError('unauthenticated', 'App Check verification required');
    }

    // Rate limiting (3 feedback submissions per hour per IP)
    if (!checkRateLimit(data.ipHash, 'feedback', 3, 60 * 60 * 1000)) {
      throw new functions.https.HttpsError('resource-exhausted', 'Rate limit exceeded');
    }

    // Validate required fields
    if (!data.category || !data.rating || !data.title || !data.message) {
      throw new functions.https.HttpsError('invalid-argument', 'Missing required fields');
    }

    // Validate rating
    if (data.rating < 1 || data.rating > 5) {
      throw new functions.https.HttpsError('invalid-argument', 'Invalid rating value');
    }

    // Sanitize inputs
    const sanitizedData: FeedbackSubmission = {
      ...data,
      title: sanitizeInput(data.title),
      message: sanitizeInput(data.message),
      timestamp: getTimestamp()
    };

    // Store feedback submission
    const submissionRef = await db.collection('submissions').add({
      type: 'feedback',
      ...sanitizedData,
      status: 'pending'
    });

    // Log analytics event
    await db.collection('analytics').add({
      type: 'feedback_submission',
      category: data.category,
      rating: data.rating,
      timestamp: getTimestamp(),
      ipHash: data.ipHash
    });

    return {
      success: true,
      submissionId: submissionRef.id,
      message: 'Feedback submitted successfully'
    };

  } catch (error) {
    console.error('Feedback submission error:', error);
    throw new functions.https.HttpsError('internal', 'Failed to submit feedback');
  }
});

// 3. Claim Volunteer Role Function
export const claimVolunteerRole = functions.https.onCall(async (request: any) => {
  try {
    const data = request.data as VolunteerSignup;
    const context = request;
    
    // Check App Check (skip in emulator and development for testing)
    if (process.env.FUNCTIONS_EMULATOR !== 'true' && process.env.NODE_ENV !== 'development' && !context.app) {
      throw new functions.https.HttpsError('unauthenticated', 'App Check required');
    }

    // Rate limiting (2 volunteer signups per hour per IP)
    if (!checkRateLimit(data.ipHash, 'volunteer', 2, 60 * 60 * 1000)) {
      throw new functions.https.HttpsError('resource-exhausted', 'Rate limit exceeded');
    }

    // Validate required fields
    if (!data.volunteerNeedId || !data.volunteerName || !data.email || !data.age || !data.skills || !data.availability || !data.experience) {
      throw new functions.https.HttpsError('invalid-argument', 'Missing required fields');
    }

    // Validate email
    if (!validateEmail(data.email)) {
      throw new functions.https.HttpsError('invalid-argument', 'Invalid email format');
    }

    // Validate age
    if (data.age < 0 || data.age > 120) {
      throw new functions.https.HttpsError('invalid-argument', 'Invalid age value');
    }

    // Sanitize inputs
    const sanitizedData: VolunteerSignup = {
      ...data,
      volunteerName: sanitizeInput(data.volunteerName),
      availability: sanitizeInput(data.availability),
      experience: sanitizeInput(data.experience),
      specialNeeds: data.specialNeeds ? sanitizeInput(data.specialNeeds) : undefined,
      emergencyContact: data.emergencyContact ? sanitizeInput(data.emergencyContact) : undefined,
      timestamp: getTimestamp()
    };

    // Check volunteer need availability
    const volunteerNeedRef = db.collection('volunteer-needs').doc(data.volunteerNeedId);
    const volunteerNeedDoc = await volunteerNeedRef.get();
    
    if (!volunteerNeedDoc.exists) {
      throw new functions.https.HttpsError('not-found', 'Volunteer role not found');
    }

    const volunteerNeed = volunteerNeedDoc.data();
    if (volunteerNeed!.currentVolunteers >= volunteerNeed!.maxVolunteers) {
      throw new functions.https.HttpsError('resource-exhausted', 'Volunteer role is full');
    }

    // Store volunteer signup
    const submissionRef = await db.collection('submissions').add({
      type: 'volunteer',
      ...sanitizedData,
      status: 'pending'
    });

    // Update volunteer need count
    await volunteerNeedRef.update({
      currentVolunteers: admin.firestore.FieldValue.increment(1)
    });

    // Log analytics event
    await db.collection('analytics').add({
      type: 'volunteer_signup',
      volunteerNeedId: data.volunteerNeedId,
      skills: data.skills,
      timestamp: getTimestamp(),
      ipHash: data.ipHash
    });

    return {
      success: true,
      submissionId: submissionRef.id,
      message: 'Volunteer role claimed successfully'
    };

  } catch (error) {
    console.error('Volunteer signup error:', error);
    throw new functions.https.HttpsError('internal', 'Failed to claim volunteer role');
  }
});

// 4. ICS Feed Generator Function
export const icsFeed = functions.https.onCall(async (request: any) => {
  try {
    const data = request.data as {
      season?: string;
      categories?: string[];
      denTags?: string[];
      startDate?: string;
      endDate?: string;
    };
    const context = request;
    
    // Check App Check (skip in emulator and development for testing)
    if (process.env.FUNCTIONS_EMULATOR !== 'true' && process.env.NODE_ENV !== 'development' && !context.app) {
      throw new functions.https.HttpsError('unauthenticated', 'App Check required');
    }

    // Build query
    let query = db.collection('events').where('startDate', '>=', getTimestamp());
    
    if (data.season) {
      query = query.where('season', '==', data.season);
    }
    
    if (data.categories && data.categories.length > 0) {
      query = query.where('category', 'in', data.categories);
    }

    const eventsSnapshot = await query.get();
    const events: Event[] = [];

    eventsSnapshot.forEach((doc: admin.firestore.QueryDocumentSnapshot) => {
      const event = doc.data() as Event;
      
      // Filter by den tags if specified
      if (data.denTags && data.denTags.length > 0) {
        if (!event.denTags.some(tag => data.denTags!.includes(tag))) {
          return;
        }
      }
      
      // Filter by date range if specified
      if (data.startDate && data.endDate) {
        const startDate = new Date(data.startDate);
        const endDate = new Date(data.endDate);
        if (event.startDate.toDate() < startDate || event.startDate.toDate() > endDate) {
          return;
        }
      }
      
      events.push(event);
    });

    // Generate ICS content
    let icsContent = 'BEGIN:VCALENDAR\r\nVERSION:2.0\r\nPRODID:-//Pack 1703//Events//EN\r\n';
    
    events.forEach(event => {
      const startDate = event.startDate.toDate();
      const endDate = event.endDate.toDate();
      
      icsContent += `BEGIN:VEVENT\r\n`;
      icsContent += `UID:${event.id}@pack1703.com\r\n`;
      icsContent += `DTSTART:${startDate.toISOString().replace(/[-:]/g, '').split('.')[0]}Z\r\n`;
      icsContent += `DTEND:${endDate.toISOString().replace(/[-:]/g, '').split('.')[0]}Z\r\n`;
      icsContent += `SUMMARY:${event.title}\r\n`;
      icsContent += `DESCRIPTION:${event.description}\r\n`;
      icsContent += `LOCATION:${event.location}\r\n`;
      icsContent += `END:VEVENT\r\n`;
    });
    
    icsContent += 'END:VCALENDAR\r\n';

    return {
      success: true,
      icsContent: icsContent,
      eventCount: events.length,
      message: 'ICS feed generated successfully'
    };

  } catch (error) {
    console.error('ICS feed generation error:', error);
    throw new functions.https.HttpsError('internal', 'Failed to generate ICS feed');
  }
});

// 5. Weather Proxy Function
export const weatherProxy = functions.https.onCall(async (request: any) => {
  try {
    const data = request.data as {
      latitude: number;
      longitude: number;
    };
    const context = request;
    
    // Check App Check (skip in emulator and development for testing)
    if (process.env.FUNCTIONS_EMULATOR !== 'true' && process.env.NODE_ENV !== 'development' && !context.app) {
      throw new functions.https.HttpsError('unauthenticated', 'App Check required');
    }

    // Validate coordinates
    if (data.latitude < -90 || data.latitude > 90 || data.longitude < -180 || data.longitude > 180) {
      throw new functions.https.HttpsError('invalid-argument', 'Invalid coordinates');
    }

    // Fetch weather from Open-Meteo API
    const response = await fetch(
      `https://api.open-meteo.com/v1/forecast?latitude=${data.latitude}&longitude=${data.longitude}&current=temperature_2m,relative_humidity_2m,precipitation_probability,weather_code&hourly=temperature_2m,precipitation_probability,weather_code&timezone=auto`
    );

    if (!response.ok) {
      throw new functions.https.HttpsError('unavailable', 'Weather service unavailable');
    }

    const weatherData = await response.json();

    // Cache weather data for 10 minutes
    await db.collection('weather-cache').doc(`${data.latitude}_${data.longitude}`).set({
      data: weatherData,
      timestamp: getTimestamp(),
      expiresAt: new Date(Date.now() + 10 * 60 * 1000)
    });

    return {
      success: true,
      weather: weatherData,
      message: 'Weather data retrieved successfully'
    };

  } catch (error) {
    console.error('Weather proxy error:', error);
    throw new functions.https.HttpsError('internal', 'Failed to retrieve weather data');
  }
});

// 6. Moderation Digest Function (runs daily)
export const moderationDigest = functions.pubsub.schedule('0 9 * * *').onRun(async (context: functions.EventContext) => {
  try {
    // Get pending submissions from the last 24 hours
    const yesterday = new Date(Date.now() - 24 * 60 * 60 * 1000);
    
    const submissionsSnapshot = await db.collection('submissions')
      .where('timestamp', '>=', yesterday)
      .where('status', '==', 'pending')
      .get();

    if (submissionsSnapshot.empty) {
      console.log('No pending submissions for moderation digest');
      return;
    }

    // Group submissions by type
    const submissionsByType = {
      rsvp: 0,
      feedback: 0,
      volunteer: 0
    };

    submissionsSnapshot.forEach((doc: admin.firestore.QueryDocumentSnapshot) => {
      const submission = doc.data();
      submissionsByType[submission.type as keyof typeof submissionsByType]++;
    });

    // Create digest document
    await db.collection('moderation-digests').add({
      date: getTimestamp(),
      totalSubmissions: submissionsSnapshot.size,
      submissionsByType,
      status: 'pending'
    });

    console.log(`Moderation digest created: ${submissionsSnapshot.size} pending submissions`);
    
    // Scheduled functions should not return values
  } catch (error) {
    console.error('Moderation digest error:', error);
    throw error;
  }
});

// 7. Hello World Function (for testing)
export const helloWorld = functions.https.onCall(async (data: any, context: functions.https.CallableContext) => {
  try {
    return {
      message: 'Hello from Firebase Cloud Functions!',
      timestamp: getTimestamp(),
      data: data
    };
  } catch (error) {
    console.error('HelloWorld error:', error);
    return {
      message: 'Hello from Firebase Cloud Functions!',
      timestamp: getTimestamp(),
      data: data
    };
  }
});

// 8. Email Monitoring Functions
export const testEmailConnection = functions.https.onCall(async (data: any, context: functions.https.CallableContext) => {
  try {
    // Check authentication
    if (!context.auth) {
      throw new functions.https.HttpsError('unauthenticated', 'User must be authenticated');
    }

    // Check if user has admin privileges
    const userDoc = await db.collection('users').doc(context.auth.uid).get();
    if (!userDoc.exists) {
      throw new functions.https.HttpsError('permission-denied', 'User not found');
    }

    const userData = userDoc.data();
    if (!userData?.role || !['admin', 'root', 'cubmaster'].includes(userData.role)) {
      throw new functions.https.HttpsError('permission-denied', 'Insufficient permissions to test email connection');
    }

    // Use default email configuration if not provided
    const { 
      emailAddress = 'test@example.com', 
      imapServer = 'imap.gmail.com', 
      imapPort = 993 
    } = data || {};

    // For now, return a mock success response since we don't have real email credentials
    return {
      success: true,
      message: 'Email connection test completed (mock response)',
      details: {
        emailAddress,
        imapServer,
        imapPort,
        note: 'This is a mock response. Configure real email credentials for actual testing.'
      }
    };

  } catch (error) {
    console.error('Test email connection error:', error);
    throw new functions.https.HttpsError('internal', 'Failed to test email connection');
  }
});

export const fetchNewEmails = functions.https.onCall(async (data: any, context: functions.https.CallableContext) => {
  try {
    // Check authentication
    if (!context.auth) {
      throw new functions.https.HttpsError('unauthenticated', 'User must be authenticated');
    }

    const { emailAddress, password, imapServer, imapPort, lastChecked } = data as {
      emailAddress: string;
      password: string;
      imapServer: string;
      imapPort: number;
      lastChecked?: string;
    };

    if (!emailAddress || !password || !imapServer || !imapPort) {
      throw new functions.https.HttpsError('invalid-argument', 'Missing required email configuration');
    }

    return new Promise((resolve, reject) => {
      const imap = new Imap({
        user: emailAddress,
        password: password,
        host: imapServer,
        port: imapPort,
        tls: true,
        tlsOptions: { rejectUnauthorized: false }
      });

      const emails: any[] = [];

      imap.once('ready', () => {
        imap.openBox('INBOX', false, (err: Error | null, box: any) => {
          if (err) {
            console.error('Error opening inbox:', err);
            imap.end();
            reject(new functions.https.HttpsError('unavailable', `Failed to open inbox: ${err.message}`));
            return;
          }

          // Search for unread emails or emails from the last check
          const searchCriteria = lastChecked 
            ? ['UNSEEN', ['SINCE', new Date(lastChecked)]]
            : ['UNSEEN'];

          imap.search(searchCriteria, (err: Error | null, results: number[]) => {
            if (err) {
              console.error('Error searching emails:', err);
              imap.end();
              reject(new functions.https.HttpsError('unavailable', `Failed to search emails: ${err.message}`));
              return;
            }

            if (results.length === 0) {
              console.log('No new emails found');
              imap.end();
              resolve({
                success: true,
                emails: [],
                message: 'No new emails found'
              });
              return;
            }

            console.log(`Found ${results.length} new emails`);

            const fetch = imap.fetch(results, { bodies: '', markSeen: false });

            fetch.on('message', (msg: any, seqno: number) => {
              const email: any = {
                id: '',
                from: '',
                to: '',
                subject: '',
                body: '',
                date: new Date(),
                attachments: []
              };

              msg.on('body', (stream: any, info: any) => {
                let buffer = '';
                stream.on('data', (chunk: Buffer) => {
                  buffer += chunk.toString('utf8');
                });
                stream.once('end', () => {
                  // Parse email headers and body
                  const parsed = parseEmail(buffer);
                  email.id = `${seqno}_${Date.now()}`;
                  email.from = parsed.from;
                  email.to = parsed.to;
                  email.subject = parsed.subject;
                  email.body = parsed.body;
                  email.date = parsed.date;
                });
              });

              msg.once('end', () => {
                emails.push(email);
              });
            });

            fetch.once('error', (err: Error) => {
              console.error('Error fetching emails:', err);
              imap.end();
              reject(new functions.https.HttpsError('unavailable', `Failed to fetch emails: ${err.message}`));
            });

            fetch.once('end', () => {
              console.log(`Successfully fetched ${emails.length} emails`);
              imap.end();
              resolve({
                success: true,
                emails: emails,
                message: `Successfully fetched ${emails.length} emails`
              });
            });
          });
        });
      });

      imap.once('error', (err: Error) => {
        console.error('IMAP connection error:', err);
        reject(new functions.https.HttpsError('unavailable', `IMAP connection failed: ${err.message}`));
      });

      imap.connect();
    });

  } catch (error) {
    console.error('Fetch new emails error:', error);
    throw new functions.https.HttpsError('internal', 'Failed to fetch emails');
  }
});

// Helper function to parse email content
function parseEmail(rawEmail: string): { from: string; to: string; subject: string; body: string; date: Date } {
  const lines = rawEmail.split('\n');
  let from = '';
  let to = '';
  let subject = '';
  let body = '';
  let inBody = false;

  for (const line of lines) {
    if (inBody) {
      body += line + '\n';
      continue;
    }

    if (line.startsWith('From: ')) {
      from = line.substring(6).trim();
    } else if (line.startsWith('To: ')) {
      to = line.substring(4).trim();
    } else if (line.startsWith('Subject: ')) {
      subject = line.substring(9).trim();
    } else if (line.startsWith('Date: ')) {
      // Parse date if needed
    } else if (line === '') {
      // Empty line indicates start of body
      inBody = true;
    }
  }

  return {
    from,
    to,
    subject,
    body: body.trim(),
    date: new Date()
  };
}

// Cloud function to safely fetch URL content for Wolf Watch emails

// Cloud function to perform web searches for event enhancement
export const webSearch = functions.https.onCall(async (data: any, context: functions.https.CallableContext) => {
  try {
    const { query, maxResults = 5 } = data as { query: string; maxResults?: number };
    
    if (!query) {
      throw new functions.https.HttpsError('invalid-argument', 'Search query is required');
    }

    // Use Google Custom Search API for better results
    let GOOGLE_API_KEY: string;
    let GOOGLE_CSE_ID: string;
    
    try {
      // Note: Google Custom Search API keys are not in our current Secret Manager setup
      // For now, fall back to environment variables or DuckDuckGo
      GOOGLE_API_KEY = process.env.GOOGLE_API_KEY || '';
      GOOGLE_CSE_ID = process.env.GOOGLE_CSE_ID || '';
    } catch (error) {
      functions.logger.warn('Failed to load API keys from Secret Manager:', error);
      GOOGLE_API_KEY = process.env.GOOGLE_API_KEY || '';
      GOOGLE_CSE_ID = process.env.GOOGLE_CSE_ID || '';
    }
    
    if (!GOOGLE_API_KEY || !GOOGLE_CSE_ID) {
      console.warn('Google API credentials not configured, falling back to DuckDuckGo');
      
      // Fallback to DuckDuckGo if Google API is not configured
      const searchUrl = `https://api.duckduckgo.com/?q=${encodeURIComponent(query)}&format=json&no_html=1&skip_disambig=1`;
      
      const response = await fetch(searchUrl, {
        method: 'GET',
        headers: {
          'User-Agent': 'Pack1703-AI/1.0',
          'Accept': 'application/json'
        },
        signal: AbortSignal.timeout(10000) // 10 second timeout
      });

      if (!response.ok) {
        throw new functions.https.HttpsError('unavailable', `Search API returned ${response.status}`);
      }

      const searchData = await response.json();
      
      // Process DuckDuckGo search results
      const results = [];
      
      if (searchData.AbstractURL) {
        results.push({
          title: searchData.Heading || 'Search Result',
          link: searchData.AbstractURL,
          snippet: searchData.AbstractText || '',
          source: 'DuckDuckGo'
        });
      }
      
      if (searchData.RelatedTopics && searchData.RelatedTopics.length > 0) {
        for (let i = 0; i < Math.min(maxResults - 1, searchData.RelatedTopics.length); i++) {
          const topic = searchData.RelatedTopics[i];
          if (topic.FirstURL && topic.Text) {
            results.push({
              title: topic.Text.split(' - ')[0] || 'Related Topic',
              link: topic.FirstURL,
              snippet: topic.Text,
              source: 'DuckDuckGo'
            });
          }
        }
      }

      return {
        success: true,
        results: results.slice(0, maxResults),
        query: query,
        totalResults: results.length
      };
    }

    // Use Google Custom Search API
    const googleSearchUrl = `https://www.googleapis.com/customsearch/v1?key=${GOOGLE_API_KEY}&cx=${GOOGLE_CSE_ID}&q=${encodeURIComponent(query)}&num=${maxResults}`;
    
    const response = await fetch(googleSearchUrl, {
      method: 'GET',
      headers: {
        'Accept': 'application/json'
      },
      signal: AbortSignal.timeout(15000) // 15 second timeout for Google API
    });

    if (!response.ok) {
      throw new functions.https.HttpsError('unavailable', `Google Search API returned ${response.status}`);
    }

    const searchData = await response.json();
    
    // Process Google search results
    const results = [];
    
    if (searchData.items && Array.isArray(searchData.items)) {
      for (const item of searchData.items) {
        results.push({
          title: item.title || 'Search Result',
          link: item.link || '',
          snippet: item.snippet || '',
          source: 'Google'
        });
      }
    }

    return {
      success: true,
      results: results.slice(0, maxResults),
      query: query,
      totalResults: results.length,
      searchInformation: searchData.searchInformation
    };

  } catch (error) {
    console.error('Error performing web search:', error);
    
    if (error instanceof functions.https.HttpsError) {
      throw error;
    }
    
    throw new functions.https.HttpsError('internal', 'Failed to perform web search');
  }
});

// Admin Cloud Function for User Management
export const adminUpdateUser = functions.https.onCall(async (request: any) => {
  try {
    const data = request.data as {
      userId: string;
      updates: {
        displayName?: string;
        role?: string;
        permissions?: string[];
        isActive?: boolean;
        profile?: any;
      };
    };
    const context = request;
    
    // Check authentication
    if (!context.auth) {
      throw new functions.https.HttpsError('unauthenticated', 'User must be authenticated');
    }

    // Check if user has admin privileges
    const userDoc = await db.collection('users').doc(context.auth.uid).get();
    if (!userDoc.exists) {
      throw new functions.https.HttpsError('permission-denied', 'User not found');
    }

    const userData = userDoc.data();
    // Check role-based permissions (new system) or legacy boolean fields
    const hasAdminRole = userData?.role === 'root' || userData?.role === 'admin' || userData?.role === 'leader';
    const hasLegacyPermissions = userData?.isAdmin || userData?.isDenLeader || userData?.isCubmaster;
    const hasUserManagementPermission = userData?.permissions?.includes('user_management') || userData?.permissions?.includes('system_admin');
    
    if (!hasAdminRole && !hasLegacyPermissions && !hasUserManagementPermission) {
      throw new functions.https.HttpsError('permission-denied', 'Insufficient permissions to update users');
    }

    const { userId, updates } = data;
    
    if (!userId) {
      throw new functions.https.HttpsError('invalid-argument', 'User ID is required');
    }

    // Check if target user exists
    const targetUserDoc = await db.collection('users').doc(userId).get();
    if (!targetUserDoc.exists) {
      throw new functions.https.HttpsError('not-found', 'Target user not found');
    }

    // Prepare update data
    const updateData: any = {
      updatedAt: getTimestamp()
    };

    if (updates.displayName !== undefined) {
      updateData.displayName = updates.displayName;
    }

    if (updates.isActive !== undefined) {
      updateData.isActive = updates.isActive;
    }

    if (updates.profile !== undefined) {
      updateData.profile = updates.profile;
    }

    // Update Firestore document
    await db.collection('users').doc(userId).update(updateData);

    // Update Firebase Auth custom claims if role is being changed
    if (updates.role !== undefined) {
      await auth.setCustomUserClaims(userId, {
        approved: true,
        role: updates.role
      });
      
      // Also update the role in Firestore
      await db.collection('users').doc(userId).update({
        role: updates.role,
        permissions: updates.permissions || [],
        updatedAt: getTimestamp()
      });
    }

    // Log admin action
    await db.collection('adminActions').add({
      userId: context.auth.uid,
      userEmail: context.auth.token.email || '',
      action: 'update',
      entityType: 'user',
      entityId: userId,
      entityName: updates.displayName || 'User',
      details: updates,
      timestamp: getTimestamp(),
      ipAddress: context.rawRequest.ip || 'unknown',
      userAgent: context.rawRequest.headers['user-agent'] || 'unknown',
      success: true
    });

    return {
      success: true,
      message: 'User updated successfully'
    };

  } catch (error) {
    console.error('Error in adminUpdateUser:', error);
    
    // Log failed action
    try {
      await db.collection('adminActions').add({
        userId: request.auth?.uid || 'unknown',
        userEmail: request.auth?.token?.email || '',
        action: 'update',
        entityType: 'user',
        entityId: request.data?.userId || 'unknown',
        entityName: 'User',
        details: request.data?.updates || {},
        timestamp: getTimestamp(),
        ipAddress: request.rawRequest?.ip || 'unknown',
        userAgent: request.rawRequest?.headers?.['user-agent'] || 'unknown',
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      });
    } catch (logError) {
      console.error('Error logging failed action:', logError);
    }

    if (error instanceof functions.https.HttpsError) {
      throw error;
    }
    throw new functions.https.HttpsError('internal', 'Failed to update user');
  }
});

// Admin Cloud Functions for Event Management
export const adminCreateEvent = functions.https.onCall(async (data: any, context: functions.https.CallableContext) => {
  try {
    const eventData = data as {
      title: string;
      description: string;
      startDate: string;
      endDate: string;
      startTime: string;
      endTime: string;
      locationId: string;
      category: string;
      seasonId: string;
      visibility?: string;
      sendNotification?: boolean;
    };
    
    // Debug authentication context
    console.log('Debug - context.auth:', context.auth);
    console.log('Debug - context.auth.uid:', context.auth?.uid);
    console.log('Debug - context.auth.token:', context.auth?.token);
    
    // Check authentication
    if (!context.auth) {
      console.log('Debug - Authentication failed: context.auth is null/undefined');
      throw new functions.https.HttpsError('unauthenticated', 'User must be authenticated');
    }

    const userId = context.auth.uid;
    console.log('Using authenticated user ID:', userId);

    // Check if user has admin privileges
    const userDoc = await db.collection('users').doc(userId).get();
    if (!userDoc.exists) {
      throw new functions.https.HttpsError('permission-denied', 'User not found');
    }

    const userData = userDoc.data();
    // Check role-based permissions (new system) or legacy boolean fields
    const hasAdminRole = userData?.role === 'root' || userData?.role === 'admin' || userData?.role === 'leader';
    const hasLegacyPermissions = userData?.isAdmin || userData?.isDenLeader || userData?.isCubmaster;
    const hasEventManagementPermission = userData?.permissions?.includes('event_management');
    
    if (!hasAdminRole && !hasLegacyPermissions && !hasEventManagementPermission) {
      throw new functions.https.HttpsError('permission-denied', 'Insufficient permissions to create events');
    }

    // Validate required fields
    const { title, description, startDate, endDate, startTime, endTime, locationId, category, seasonId } = eventData;
    
    if (!title || !description || !startDate || !endDate || !startTime || !endTime || !locationId || !category || !seasonId) {
      throw new functions.https.HttpsError('invalid-argument', 'Missing required fields');
    }

    // Validate dates
    const startDateTime = new Date(startDate);
    const endDateTime = new Date(endDate);
    
    if (isNaN(startDateTime.getTime()) || isNaN(endDateTime.getTime())) {
      throw new functions.https.HttpsError('invalid-argument', 'Invalid date format');
    }

    if (startDateTime >= endDateTime) {
      throw new functions.https.HttpsError('invalid-argument', 'End date must be after start date');
    }

    // Validate time format (HH:MM)
    const timeRegex = /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/;
    if (!timeRegex.test(startTime) || !timeRegex.test(endTime)) {
      throw new functions.https.HttpsError('invalid-argument', 'Invalid time format. Use HH:MM');
    }

    // Check if location exists
    const locationDoc = await db.collection('locations').doc(locationId).get();
    if (!locationDoc.exists) {
      throw new functions.https.HttpsError('invalid-argument', 'Location not found');
    }

    // Check if season exists
    const seasonDoc = await db.collection('seasons').doc(seasonId).get();
    if (!seasonDoc.exists) {
      throw new functions.https.HttpsError('invalid-argument', 'Season not found');
    }

    // Check for duplicate events (same title, date, and location)
    const existingEvents = await db.collection('events')
      .where('title', '==', title)
      .where('startDate', '==', startDateTime)
      .where('locationId', '==', locationId)
      .get();

    if (!existingEvents.empty) {
      throw new functions.https.HttpsError('already-exists', 'An event with this title, date, and location already exists');
    }

    // Create event document
    const eventDoc = {
      ...eventData,
      startDate: startDateTime,
      endDate: endDateTime,
      currentParticipants: 0,
      createdAt: getTimestamp(),
      updatedAt: getTimestamp(),
      createdBy: userId,
      status: 'active',
      visibility: eventData.visibility || 'public'
    };

    const eventRef = await db.collection('events').add(eventDoc);
    const eventId = eventRef.id;

    // Log admin action
    await db.collection('adminActions').add({
      userId: userId,
      userEmail: context.auth.token?.email || 'unknown',
      action: 'create',
      entityType: 'event',
      entityId: eventId,
      entityName: title,
      details: eventData,
      timestamp: getTimestamp(),
      ipAddress: context.rawRequest.ip || 'unknown',
      userAgent: context.rawRequest.headers['user-agent'] || 'unknown',
      success: true
    });

    // Send notification to chat if enabled
    if (eventData.sendNotification !== false) {
      try {
        const locationData = locationDoc.data();
        const notificationMessage = `ðŸŽ‰ **New Event Created!**\n\n**${title}**\nðŸ“… ${startDate} ${startTime} - ${endTime}\nðŸ“ ${locationData?.name || 'TBD'}\n\n${description.substring(0, 100)}${description.length > 100 ? '...' : ''}`;
        
        // Send to general chat
        await db.collection('chatMessages').add({
          channelId: 'general',
          message: notificationMessage,
          senderId: 'system',
          senderName: 'System',
          senderEmail: 'system@sfpack1703.com',
          timestamp: getTimestamp(),
          type: 'event_created'
        });
      } catch (notificationError) {
        console.error('Failed to send event notification:', notificationError);
      }
    }

    return {
      success: true,
      eventId: eventId,
      message: 'Event created successfully'
    };

  } catch (error) {
    console.error('Error creating event:', error);
    
    if (error instanceof functions.https.HttpsError) {
      throw error;
    }
    
    throw new functions.https.HttpsError('internal', 'Failed to create event');
  }
});

// Admin function to update user role (for fixing permission issues)
export const updateUserRole = functions.https.onCall(async (data: any, context: functions.https.CallableContext) => {
  try {
    const { userId, newRole, email } = data;
    
    // Check authentication
    if (!context.auth) {
      throw new functions.https.HttpsError('unauthenticated', 'User must be authenticated');
    }

    // Only allow the user to update their own role, or require admin privileges
    if (context.auth.uid !== userId) {
      // Check if current user has admin privileges
      const currentUserDoc = await db.collection('users').doc(context.auth.uid).get();
      if (!currentUserDoc.exists) {
        throw new functions.https.HttpsError('permission-denied', 'Current user not found');
      }
      
      const currentUserData = currentUserDoc.data();
      const hasAdminRole = currentUserData?.role === 'root' || currentUserData?.role === 'admin';
      const hasLegacyPermissions = currentUserData?.isAdmin || currentUserData?.isDenLeader || currentUserData?.isCubmaster;
      
      if (!hasAdminRole && !hasLegacyPermissions) {
        throw new functions.https.HttpsError('permission-denied', 'Only admins can update other users');
      }
    }

    // Validate role
    const validRoles = ['parent', 'volunteer', 'admin', 'root'];
    if (!validRoles.includes(newRole)) {
      throw new functions.https.HttpsError('invalid-argument', 'Invalid role');
    }

    // Update user role
    const updateData: any = {
      role: newRole,
      updatedAt: getTimestamp()
    };

    // Set appropriate boolean flags based on role
    if (newRole === 'admin' || newRole === 'root') {
      updateData.isAdmin = true;
      updateData.isDenLeader = true;
      updateData.isCubmaster = true;
      updateData.permissions = ['event_management', 'pack_management', 'user_management', 'location_management', 'announcement_management'];
    } else if (newRole === 'volunteer') {
      updateData.isDenLeader = true;
      updateData.permissions = ['den_content', 'den_events', 'den_members'];
    } else {
      updateData.isAdmin = false;
      updateData.isDenLeader = false;
      updateData.isCubmaster = false;
      updateData.permissions = ['family_management', 'family_events', 'family_rsvp'];
    }

    await db.collection('users').doc(userId).update(updateData);

    // Log admin action
    await db.collection('adminActions').add({
      userId: context.auth.uid,
      userEmail: context.auth.token.email || '',
      action: 'update_role',
      entityType: 'user',
      entityId: userId,
      entityName: email || 'User',
      details: { oldRole: 'unknown', newRole: newRole },
      timestamp: getTimestamp(),
      ipAddress: context.rawRequest.ip || 'unknown',
      userAgent: context.rawRequest.headers['user-agent'] || 'unknown',
      success: true
    });

    return {
      success: true,
      message: `User role updated to ${newRole} successfully`
    };

  } catch (error) {
    console.error('Error updating user role:', error);
    
    if (error instanceof functions.https.HttpsError) {
      throw error;
    }
    
    throw new functions.https.HttpsError('internal', 'Failed to update user role');
  }
});

export const adminUpdateEvent = functions.https.onCall(async (request: any) => {
  try {
    const data = request.data as { eventId: string; eventData: any };
    const context = request;
    
    // Debug authentication context
    console.log('Debug adminUpdateEvent - context.auth:', context.auth);
    console.log('Debug adminUpdateEvent - context.auth.uid:', context.auth?.uid);
    console.log('Debug adminUpdateEvent - context.auth.token:', context.auth?.token);
    
    // Check authentication
    if (!context.auth) {
      console.log('Debug adminUpdateEvent - Authentication failed: context.auth is null/undefined');
      throw new functions.https.HttpsError('unauthenticated', 'User must be authenticated');
    }

    // Check if user has admin privileges
    const userDoc = await db.collection('users').doc(context.auth.uid).get();
    if (!userDoc.exists) {
      console.log('Debug adminUpdateEvent - User not found in Firestore:', context.auth.uid);
      throw new functions.https.HttpsError('permission-denied', 'User not found');
    }

    const userData = userDoc.data();
    console.log('Debug adminUpdateEvent - User data:', userData);
    console.log('Debug adminUpdateEvent - User role:', userData?.role);
    console.log('Debug adminUpdateEvent - User isAdmin:', userData?.isAdmin);
    console.log('Debug adminUpdateEvent - User isDenLeader:', userData?.isDenLeader);
    console.log('Debug adminUpdateEvent - User isCubmaster:', userData?.isCubmaster);
    
    // Check role-based permissions (new system) or legacy boolean fields
    const hasAdminRole = userData?.role === 'root' || userData?.role === 'admin' || userData?.role === 'leader';
    const hasLegacyPermissions = userData?.isAdmin || userData?.isDenLeader || userData?.isCubmaster;
    const hasEventManagementPermission = userData?.permissions?.includes('event_management');
    
    console.log('Debug adminUpdateEvent - hasAdminRole:', hasAdminRole);
    console.log('Debug adminUpdateEvent - hasLegacyPermissions:', hasLegacyPermissions);
    console.log('Debug adminUpdateEvent - hasEventManagementPermission:', hasEventManagementPermission);
    
    if (!hasAdminRole && !hasLegacyPermissions && !hasEventManagementPermission) {
      console.log('Debug adminUpdateEvent - Permission denied for user:', context.auth.uid);
      throw new functions.https.HttpsError('permission-denied', 'Insufficient permissions to update events');
    }

    const { eventId, eventData } = data;
    
    if (!eventId) {
      throw new functions.https.HttpsError('invalid-argument', 'Event ID is required');
    }

    // Check if event exists
    const eventDoc = await db.collection('events').doc(eventId).get();
    if (!eventDoc.exists) {
      throw new functions.https.HttpsError('not-found', 'Event not found');
    }

    const existingEvent = eventDoc.data();
    if (!existingEvent) {
      throw new functions.https.HttpsError('not-found', 'Event data not found');
    }

    // Validate dates if provided
    if (eventData.startDate && eventData.endDate) {
      const startDateTime = new Date(eventData.startDate);
      const endDateTime = new Date(eventData.endDate);
      
      if (isNaN(startDateTime.getTime()) || isNaN(endDateTime.getTime())) {
        throw new functions.https.HttpsError('invalid-argument', 'Invalid date format');
      }

      if (startDateTime >= endDateTime) {
        throw new functions.https.HttpsError('invalid-argument', 'End date must be after start date');
      }
    }

    // Validate time format if provided
    if (eventData.startTime || eventData.endTime) {
      const timeRegex = /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/;
      if (eventData.startTime && !timeRegex.test(eventData.startTime)) {
        throw new functions.https.HttpsError('invalid-argument', 'Invalid start time format. Use HH:MM');
      }
      if (eventData.endTime && !timeRegex.test(eventData.endTime)) {
        throw new functions.https.HttpsError('invalid-argument', 'Invalid end time format. Use HH:MM');
      }
    }

    // Check location if provided
    if (eventData.locationId) {
      const locationDoc = await db.collection('locations').doc(eventData.locationId).get();
      if (!locationDoc.exists) {
        throw new functions.https.HttpsError('invalid-argument', 'Location not found');
      }
    }

    // Check season if provided
    if (eventData.seasonId) {
      const seasonDoc = await db.collection('seasons').doc(eventData.seasonId).get();
      if (!seasonDoc.exists) {
        throw new functions.https.HttpsError('invalid-argument', 'Season not found');
      }
    }

    // Update event
    const updateData = {
      ...eventData,
      updatedAt: getTimestamp(),
      updatedBy: context.auth.uid
    };

    await db.collection('events').doc(eventId).update(updateData);

    // Log admin action
    await db.collection('adminActions').add({
      userId: context.auth.uid,
      userEmail: context.auth.token.email || '',
      action: 'update',
      entityType: 'event',
      entityId: eventId,
      entityName: eventData.title || existingEvent.title,
      details: { old: existingEvent, new: updateData },
      timestamp: getTimestamp(),
      ipAddress: context.rawRequest.ip || 'unknown',
      userAgent: context.rawRequest.headers['user-agent'] || 'unknown',
      success: true
    });

    return {
      success: true,
      message: 'Event updated successfully'
    };

  } catch (error) {
    console.error('Error updating event:', error);
    
    if (error instanceof functions.https.HttpsError) {
      throw error;
    }
    
    throw new functions.https.HttpsError('internal', 'Failed to update event');
  }
});

export const adminDeleteEvent = functions.https.onCall(async (request: any) => {
  try {
    const data = request.data as { eventId: string; reason?: string };
    const context = request;
    
    // Check authentication
    if (!context.auth) {
      throw new functions.https.HttpsError('unauthenticated', 'User must be authenticated');
    }

    // Check if user has admin privileges
    const userDoc = await db.collection('users').doc(context.auth.uid).get();
    if (!userDoc.exists) {
      throw new functions.https.HttpsError('permission-denied', 'User not found');
    }

    const userData = userDoc.data();
    // Check role-based permissions (new system) or legacy boolean fields
    const hasAdminRole = userData?.role === 'root' || userData?.role === 'admin' || userData?.role === 'leader';
    const hasLegacyPermissions = userData?.isAdmin || userData?.isDenLeader || userData?.isCubmaster;
    const hasEventManagementPermission = userData?.permissions?.includes('event_management');
    
    if (!hasAdminRole && !hasLegacyPermissions && !hasEventManagementPermission) {
      throw new functions.https.HttpsError('permission-denied', 'Insufficient permissions to delete events');
    }

    const { eventId, reason } = data;
    
    if (!eventId) {
      throw new functions.https.HttpsError('invalid-argument', 'Event ID is required');
    }

    // Check if event exists
    const eventDoc = await db.collection('events').doc(eventId).get();
    if (!eventDoc.exists) {
      throw new functions.https.HttpsError('not-found', 'Event not found');
    }

    const eventData = eventDoc.data();
    if (!eventData) {
      throw new functions.https.HttpsError('not-found', 'Event data not found');
    }

    // Check if event has RSVPs
    const rsvpDocs = await db.collection('rsvps').where('eventId', '==', eventId).get();
    if (!rsvpDocs.empty) {
      throw new functions.https.HttpsError('failed-precondition', 'Cannot delete event with existing RSVPs. Please cancel RSVPs first.');
    }

    // Delete event
    await db.collection('events').doc(eventId).delete();

    // Log admin action
    await db.collection('adminActions').add({
      userId: context.auth.uid,
      userEmail: context.auth.token.email || '',
      action: 'delete',
      entityType: 'event',
      entityId: eventId,
      entityName: eventData.title,
      details: { reason: reason || 'No reason provided', deletedEvent: eventData },
      timestamp: getTimestamp(),
      ipAddress: context.rawRequest.ip || 'unknown',
      userAgent: context.rawRequest.headers['user-agent'] || 'unknown',
      success: true
    });

    return {
      success: true,
      message: 'Event deleted successfully'
    };

  } catch (error) {
    console.error('Error deleting event:', error);
    
    if (error instanceof functions.https.HttpsError) {
      throw error;
    }
    
    throw new functions.https.HttpsError('internal', 'Failed to delete event');
  }
});

// Gemini AI Integration Function
// Temporarily disabled due to firebase-admin/ai import issue
// import GeminiService from './geminiService';

export const aiGenerateContent = functions.https.onCall(async (request: any) => {
  try {
    const data = request.data as {
      type: string;
      prompt?: string;
      eventData?: any;
      announcementData?: any;
    };
    const context = request;
    
    // Check authentication
    if (!context.auth) {
      throw new functions.https.HttpsError('unauthenticated', 'User must be authenticated');
    }

    // Check if user has admin privileges
    const userDoc = await db.collection('users').doc(context.auth.uid).get();
    if (!userDoc.exists) {
      throw new functions.https.HttpsError('permission-denied', 'User not found');
    }

    const userData = userDoc.data();
    // Check role-based permissions (new system) or legacy boolean fields
    const hasAdminRole = userData?.role === 'root' || userData?.role === 'admin' || userData?.role === 'leader';
    const hasLegacyPermissions = userData?.isAdmin || userData?.isDenLeader || userData?.isCubmaster;
    const hasAIPermission = userData?.permissions?.includes('ai_access') || userData?.permissions?.includes('system_admin');
    
    if (!hasAdminRole && !hasLegacyPermissions && !hasAIPermission) {
      throw new functions.https.HttpsError('permission-denied', 'Insufficient permissions to use AI features');
    }

    const { type, prompt, eventData, announcementData } = data;
    
    if (!type || !prompt) {
      throw new functions.https.HttpsError('invalid-argument', 'Type and prompt are required');
    }

    // Initialize Gemini service
    // Temporarily disabled due to firebase-admin/ai import issue
    // const geminiService = new GeminiService();

    let result: any = {};

    switch (type) {
      case 'event_description':
        if (!eventData) {
          throw new functions.https.HttpsError('invalid-argument', 'Event data is required for event description generation');
        }
        // Temporarily disabled due to firebase-admin/ai import issue
        // result.content = await geminiService.generateEventDescription(eventData);
        break;

      case 'announcement_content':
        if (!announcementData) {
          throw new functions.https.HttpsError('invalid-argument', 'Announcement data is required for announcement generation');
        }
        // Temporarily disabled due to firebase-admin/ai import issue
        // result.content = await geminiService.generateAnnouncementContent(announcementData);
        break;

      case 'packing_list':
        if (!eventData) {
          throw new functions.https.HttpsError('invalid-argument', 'Event data is required for packing list generation');
        }
        // Temporarily disabled due to firebase-admin/ai import issue
        // result.items = await geminiService.generatePackingList(eventData);
        break;

      case 'event_title':
        if (!eventData) {
          throw new functions.https.HttpsError('invalid-argument', 'Event data is required for title generation');
        }
        // Temporarily disabled due to firebase-admin/ai import issue
        // result.title = await geminiService.generateEventTitle(eventData);
        break;

      case 'query_analysis':
        // Temporarily disabled due to firebase-admin/ai import issue
        // result.response = await geminiService.analyzeQuery(prompt, {
        //   userRole: userData?.isAdmin ? 'admin' : 'user',
        //   availableData: data.context
        // });
        break;

      default:
        throw new functions.https.HttpsError('invalid-argument', 'Invalid content type');
    }

    // Log AI usage
    await db.collection('aiUsage').add({
      userId: context.auth.uid,
      userEmail: context.auth.token.email || '',
      type: type,
      prompt: prompt,
      result: result,
      timestamp: getTimestamp(),
      // Temporarily disabled due to firebase-admin/ai import issue
      // model: geminiService.getModelInfo().model,
      ipAddress: context.rawRequest.ip || 'unknown',
      userAgent: context.rawRequest.headers['user-agent'] || 'unknown'
    });

    return {
      success: true,
      result: result,
      // Temporarily disabled due to firebase-admin/ai import issue
      // model: geminiService.getModelInfo().model
    };

  } catch (error) {
    console.error('Error generating AI content:', error);
    
    if (error instanceof functions.https.HttpsError) {
      throw error;
    }
    
    throw new functions.https.HttpsError('internal', 'Failed to generate AI content');
  }
});

// Test GPT-5 Connection Function
export const testAIConnection = functions.https.onCall(async (data: any, context: functions.https.CallableContext) => {
  try {
    // Check authentication
    if (!context.auth) {
      throw new functions.https.HttpsError('unauthenticated', 'User must be authenticated');
    }

    // Check if user has admin privileges
    const userDoc = await db.collection('users').doc(context.auth.uid).get();
    if (!userDoc.exists) {
      throw new functions.https.HttpsError('permission-denied', 'User not found');
    }

    const userData = userDoc.data();
    if (!userData?.role || !['admin', 'root', 'cubmaster'].includes(userData.role)) {
      throw new functions.https.HttpsError('permission-denied', 'Insufficient permissions to test AI connection');
    }

    // Initialize Gemini service
    // Temporarily disabled due to firebase-admin/ai import issue
    // const geminiService = new GeminiService();
    
    // Test connection
    // Temporarily disabled due to firebase-admin/ai import issue
    // const isConnected = await geminiService.testConnection();
    // const modelInfo = geminiService.getModelInfo();

    return {
      success: true,
      connected: false, // Temporarily disabled due to firebase-admin/ai import issue
      model: 'gemini-2.5-flash', // Default model
      maxTokens: 4000, // Default max tokens
      temperature: 0.7 // Default temperature
    };

  } catch (error) {
    console.error('Error testing AI connection:', error);
    
    if (error instanceof functions.https.HttpsError) {
      throw error;
    }
    
    return {
      success: false,
      connected: false,
      error: error instanceof Error ? error.message : 'Unknown error'
    };
  }
});

// System Command Function for Root Users
export const systemCommand = functions.https.onCall(async (data: any, context: functions.https.CallableContext) => {
  try {
    
    // Check authentication
    if (!context.auth) {
      throw new functions.https.HttpsError('unauthenticated', 'User must be authenticated');
    }

    // Check if user is root
    const userDoc = await db.collection('users').doc(context.auth.uid).get();
    if (!userDoc.exists) {
      throw new functions.https.HttpsError('permission-denied', 'User not found');
    }

    const userData = userDoc.data();
    if (userData?.role !== 'root') {
      throw new functions.https.HttpsError('permission-denied', 'Only root users can execute system commands');
    }

    const { command } = data as { command: string };
    
    if (!command) {
      throw new functions.https.HttpsError('invalid-argument', 'Command is required');
    }

    console.log(`ðŸ”§ Root user ${context.auth.token.email || context.auth.uid} executing system command: ${command}`);

    let result: any = {};

    switch (command.toLowerCase()) {
      case 'ping':
        result = { status: 'pong', timestamp: new Date().toISOString() };
        break;

      case 'status':
        result = {
          status: 'operational',
          timestamp: new Date().toISOString(),
          environment: process.env.NODE_ENV || 'production',
          functions: 'running',
          database: 'connected',
          ai: 'operational'
        };
        break;

      case 'clear_cache':
        // Clear any cached data
        result = { 
          status: 'success', 
          message: 'System cache cleared',
          timestamp: new Date().toISOString()
        };
        break;

      case 'optimize_database':
        // Database optimization logic would go here
        result = { 
          status: 'success', 
          message: 'Database optimization completed',
          timestamp: new Date().toISOString()
        };
        break;

      case 'check_ai':
        try {
          // Temporarily disabled due to firebase-admin/ai import issue
    // const geminiService = new GeminiService();
          // Temporarily disabled due to firebase-admin/ai import issue
          // const isConnected = await geminiService.testConnection();
          result = { 
            status: 'success', 
            ai_connected: false, // Temporarily disabled due to firebase-admin/ai import issue
            // Temporarily disabled due to firebase-admin/ai import issue
            // model: geminiService.getModelInfo().model,
            timestamp: new Date().toISOString()
          };
        } catch (error) {
          result = { 
            status: 'error', 
            ai_connected: false,
            error: error instanceof Error ? error.message : 'Unknown error',
            timestamp: new Date().toISOString()
          };
        }
        break;

      case 'test_functions':
        result = { 
          status: 'success', 
          message: 'All functions operational',
          timestamp: new Date().toISOString()
        };
        break;

      case 'backup_data':
        // Backup logic would go here
        result = { 
          status: 'success', 
          message: 'Data backup initiated',
          timestamp: new Date().toISOString()
        };
        break;

      case 'restore_data':
        // Restore logic would go here
        result = { 
          status: 'success', 
          message: 'Data restore initiated',
          timestamp: new Date().toISOString()
        };
        break;

      case 'reset_settings':
        result = { 
          status: 'success', 
          message: 'System settings reset to defaults',
          timestamp: new Date().toISOString()
        };
        break;

      case 'emergency_shutdown':
        result = { 
          status: 'warning', 
          message: 'Emergency shutdown initiated - non-essential services disabled',
          timestamp: new Date().toISOString()
        };
        break;

      case 'disable_ai':
        result = { 
          status: 'success', 
          message: 'AI services disabled',
          timestamp: new Date().toISOString()
        };
        break;

      case 'disable_auth':
        result = { 
          status: 'warning', 
          message: 'Authentication system disabled',
          timestamp: new Date().toISOString()
        };
        break;

      case 'maintenance_mode':
        result = { 
          status: 'success', 
          message: 'Maintenance mode enabled',
          timestamp: new Date().toISOString()
        };
        break;

      default:
        throw new functions.https.HttpsError('invalid-argument', `Unknown command: ${command}`);
    }

    // Log the system command execution
    await db.collection('adminActions').add({
      userId: context.auth.uid,
      userEmail: context.auth.token.email || '',
      action: 'system_command',
      entityType: 'system',
      entityId: 'system',
      entityName: 'System Command',
      details: { 
        command: command,
        result: result,
        timestamp: getTimestamp()
      },
      timestamp: getTimestamp(),
      ipAddress: context.rawRequest.ip || 'unknown',
      userAgent: context.rawRequest.headers['user-agent'] || 'unknown',
      success: true
    });

    return {
      success: true,
      command: command,
      result: result
    };

  } catch (error) {
    console.error('Error executing system command:', error);
    
    if (error instanceof functions.https.HttpsError) {
      throw error;
    }
    
    throw new functions.https.HttpsError('internal', 'Failed to execute system command');
  }
});

// ============================================================================
// REMINDER PROCESSING FUNCTIONS
// ============================================================================

// Process scheduled reminders every 5 minutes
export const processScheduledReminders = functions.pubsub.schedule('every 5 minutes').onRun(async (context: functions.EventContext) => {
  try {
    console.log('ðŸ”” Processing scheduled reminders...');
    
    const now = admin.firestore.Timestamp.now();
    const batch = db.batch();
    let processedCount = 0;
    let errorCount = 0;

    // Get reminders that are due to be sent
    const remindersQuery = await db.collection('reminders')
      .where('status', '==', 'pending')
      .where('scheduledFor', '<=', now)
      .limit(50) // Process in batches
      .get();

    for (const doc of remindersQuery.docs) {
      try {
        const reminder = { id: doc.id, ...doc.data() };
        
        // Process the reminder
        await processReminder(reminder, batch);
        processedCount++;
        
        console.log(`âœ… Processed reminder: ${reminder.id}`);
      } catch (error) {
        console.error(`âŒ Error processing reminder ${doc.id}:`, error);
        errorCount++;
        
        // Mark reminder as failed
        batch.update(doc.ref, {
          status: 'failed',
          errorMessage: error instanceof Error ? error.message : 'Unknown error',
          lastSendAttempt: now,
          sendAttempts: (doc.data().sendAttempts || 0) + 1,
          updatedAt: now
        });
      }
    }

    // Commit all changes
    await batch.commit();

    console.log(`ðŸŽ‰ Reminder processing complete: ${processedCount} processed, ${errorCount} errors`);
    
    // Scheduled functions should not return values
  } catch (error) {
    console.error('âŒ Error in reminder processing:', error);
    throw error;
  }
});

// Process overdue reminders daily at 9 AM
export const processOverdueReminders = functions.pubsub.schedule('0 9 * * *').onRun(async (context: functions.EventContext) => {
  try {
    console.log('â° Processing overdue reminders...');
    
    const now = admin.firestore.Timestamp.now();
    const batch = db.batch();
    let escalatedCount = 0;

    // Get overdue reminders
    const overdueQuery = await db.collection('reminders')
      .where('status', 'in', ['pending', 'sent', 'acknowledged'])
      .where('dueDate', '<', now)
      .where('autoEscalate', '==', true)
      .get();

    for (const doc of overdueQuery.docs) {
      try {
        const reminder = { id: doc.id, ...doc.data() };
        
        // Escalate the reminder
        await escalateReminder(reminder, batch);
        escalatedCount++;
        
        console.log(`ðŸš¨ Escalated overdue reminder: ${reminder.id}`);
      } catch (error) {
        console.error(`âŒ Error escalating reminder ${doc.id}:`, error);
      }
    }

    // Commit all changes
    await batch.commit();

    console.log(`ðŸŽ‰ Overdue reminder processing complete: ${escalatedCount} escalated`);
    
    // Scheduled functions should not return values
  } catch (error) {
    console.error('âŒ Error in overdue reminder processing:', error);
    throw error;
  }
});

// ============================================================================
// REMINDER HELPER FUNCTIONS
// ============================================================================

async function processReminder(reminder: any, batch: admin.firestore.WriteBatch) {
  const now = admin.firestore.Timestamp.now();
  
  // Update reminder status to sent
  batch.update(db.collection('reminders').doc(reminder.id), {
    status: 'sent',
    sentAt: now,
    lastSendAttempt: now,
    sendAttempts: (reminder.sendAttempts || 0) + 1,
    updatedAt: now
  });

  // Send reminders through different channels
  const deliveryPromises = reminder.channels.map(async (channel: string) => {
    try {
      await sendReminderThroughChannel(reminder, channel);
      
      // Record delivery
      batch.create(db.collection('reminder_deliveries').doc(), {
        reminderId: reminder.id,
        recipientId: reminder.recipientIds[0], // Simplified - would need to iterate through all recipients
        channel: channel,
        status: 'sent',
        sentAt: now,
        metadata: {
          message: reminder.message,
          title: reminder.title
        }
      });
    } catch (error) {
      console.error(`Failed to send reminder through ${channel}:`, error);
      
      // Record failed delivery
      batch.create(db.collection('reminder_deliveries').doc(), {
        reminderId: reminder.id,
        recipientId: reminder.recipientIds[0],
        channel: channel,
        status: 'failed',
        sentAt: now,
        errorMessage: error instanceof Error ? error.message : 'Unknown error',
        metadata: {
          message: reminder.message,
          title: reminder.title
        }
      });
    }
  });

  await Promise.allSettled(deliveryPromises);
}

async function sendReminderThroughChannel(reminder: any, channel: string) {
  switch (channel) {
    case 'email':
      return await sendEmailReminder(reminder);
    case 'chat':
      return await sendChatReminder(reminder);
    case 'push':
      return await sendPushReminder(reminder);
    case 'sms':
      return await sendSMSReminder(reminder);
    case 'in_app':
      return await sendInAppReminder(reminder);
    default:
      throw new Error(`Unknown channel: ${channel}`);
  }
}

async function sendEmailReminder(reminder: any) {
  // This would integrate with your email service
  // For now, we'll just log it
  console.log(`ðŸ“§ Sending email reminder: ${reminder.title} to ${reminder.recipientIds.length} recipients`);
  
  // TODO: Implement actual email sending
  // You could use SendGrid, Mailgun, or Firebase Extensions for email
}

async function sendChatReminder(reminder: any) {
  // This would send to your chat system
  console.log(`ðŸ’¬ Sending chat reminder: ${reminder.title}`);
  
  // TODO: Implement chat integration
  // You could send to Slack, Discord, or your internal chat system
}

async function sendPushReminder(reminder: any) {
  // This would send push notifications
  console.log(`ðŸ“± Sending push reminder: ${reminder.title}`);
  
  // TODO: Implement push notifications
  // You could use Firebase Cloud Messaging (FCM)
}

async function sendSMSReminder(reminder: any) {
  // This would send SMS messages
  console.log(`ðŸ“ž Sending SMS reminder: ${reminder.title}`);
  
  // TODO: Implement SMS sending
  // You could use Twilio, AWS SNS, or other SMS providers
}

async function sendInAppReminder(reminder: any) {
  // This would create in-app notifications
  console.log(`ðŸ”” Creating in-app reminder: ${reminder.title}`);
  
  // Create in-app notification
  await db.collection('notifications').add({
    userId: reminder.recipientIds[0], // Simplified
    type: 'reminder',
    title: reminder.title,
    message: reminder.message,
    actionUrl: reminder.actionUrl,
    actionText: reminder.actionText,
    priority: reminder.priority,
    isRead: false,
    createdAt: admin.firestore.Timestamp.now(),
    metadata: {
      reminderId: reminder.id,
      reminderType: reminder.type
    }
  });
}

async function escalateReminder(reminder: any, batch: admin.firestore.WriteBatch) {
  const now = admin.firestore.Timestamp.now();
  
  // Update reminder priority to urgent
  batch.update(db.collection('reminders').doc(reminder.id), {
    priority: 'urgent',
    updatedAt: now
  });

  // Create escalation record
  batch.create(db.collection('reminder_escalations').doc(), {
    reminderId: reminder.id,
    escalatedAt: now,
    escalatedBy: 'system',
    reason: 'Overdue reminder',
    newPriority: 'urgent',
    notes: 'Automatically escalated due to overdue status'
  });

  // Send escalation notification to admins
  await sendEscalationNotification(reminder);
}

async function sendEscalationNotification(reminder: any) {
  console.log(`ðŸš¨ Sending escalation notification for reminder: ${reminder.title}`);
  
  // TODO: Implement escalation notification
  // This could send to admin email, create admin notification, etc.
}

// Test Secret Manager integration - TEMPORARILY DISABLED due to Node.js version compatibility
/*
export const testSecretManager = functions.https.onCall(async (request) => {
  try {
    const context = request;
    
    // Check App Check (skip in emulator and development for testing)
    if (process.env.FUNCTIONS_EMULATOR !== 'true' && process.env.NODE_ENV !== 'development' && !context.app) {
      throw new functions.https.HttpsError('unauthenticated', 'App Check required');
    }

    functions.logger.info('ðŸ§ª Testing Secret Manager integration...');
    
    const apiKeys = await secretManagerService.getAllApiKeys();
    
    // Return summary (without exposing actual keys)
    const summary = {
      admin: {
        googleMaps: apiKeys.ADMIN.GOOGLE_MAPS ? 'âœ… Configured' : 'âŒ Missing',
        openWeather: apiKeys.ADMIN.OPENWEATHER ? 'âœ… Configured' : 'âŒ Missing',
        googlePlaces: apiKeys.ADMIN.GOOGLE_PLACES ? 'âœ… Configured' : 'âŒ Missing',
      },
      user: {
        googleMaps: apiKeys.USER.GOOGLE_MAPS ? 'âœ… Configured' : 'âŒ Missing',
        openWeather: apiKeys.USER.OPENWEATHER ? 'âœ… Configured' : 'âŒ Missing',
        googlePlaces: apiKeys.USER.GOOGLE_PLACES ? 'âœ… Configured' : 'âŒ Missing',
      },
      shared: {
        phoneValidation: apiKeys.PHONE_VALIDATION ? 'âœ… Configured' : 'âŒ Missing',
        tenor: apiKeys.TENOR ? 'âœ… Configured' : 'âŒ Missing',
        recaptcha: apiKeys.RECAPTCHA.SITE_KEY ? 'âœ… Configured' : 'âŒ Missing',
      },
      cacheStats: secretManagerService.getCacheStats()
    };

    functions.logger.info('âœ… Secret Manager test completed successfully');
    
    return {
      success: true,
      message: 'Secret Manager integration working correctly',
      summary
    };

  } catch (error) {
    functions.logger.error('âŒ Secret Manager test failed:', error);
    throw new functions.https.HttpsError('internal', `Secret Manager test failed: ${error}`);
  }
});
*/

// Location management functions
export const adminCreateLocation = functions.https.onCall(async (request: any) => {
  try {
    const context = request;
    const data = request.data;
    
    // Check authentication
    if (!context.auth) {
      throw new functions.https.HttpsError('unauthenticated', 'User must be authenticated');
    }

    // Check if user has admin privileges
    const userDoc = await db.collection('users').doc(context.auth.uid).get();
    if (!userDoc.exists) {
      throw new functions.https.HttpsError('permission-denied', 'User not found');
    }

    const userData = userDoc.data();
    const hasAdminRole = userData?.role === 'root' || userData?.role === 'admin' || userData?.role === 'volunteer';
    const hasLegacyPermissions = userData?.isAdmin || userData?.isDenLeader || userData?.isCubmaster;
    const hasLocationPermission = userData?.permissions?.includes('location_management') || userData?.permissions?.includes('system_admin');
    
    if (!hasAdminRole && !hasLegacyPermissions && !hasLocationPermission) {
      throw new functions.https.HttpsError('permission-denied', 'Insufficient permissions to create locations');
    }

    // Validate required fields
    if (!data.name || !data.address || !data.city || !data.state) {
      throw new functions.https.HttpsError('invalid-argument', 'Missing required fields: name, address, city, state');
    }

    // Create location document
    const locationData = {
      name: data.name,
      address: data.address,
      city: data.city,
      state: data.state,
      zipCode: data.zipCode || '',
      category: data.category || 'other',
      importance: data.importance || 'medium',
      parking: data.parking || 'free',
      notes: data.notes || '',
      privateNotes: data.privateNotes || '',
      isActive: data.isActive !== false,
      createdAt: getTimestamp(),
      updatedAt: getTimestamp(),
      createdBy: context.auth.uid
    };

    const locationRef = await db.collection('locations').add(locationData);

    // Log admin action
    await db.collection('adminActions').add({
      userId: context.auth.uid,
      userEmail: userData?.email || 'unknown',
      action: 'create',
      entityType: 'location',
      entityId: locationRef.id,
      entityName: data.name,
      details: { locationData },
      timestamp: getTimestamp(),
      success: true
    });

    return {
      success: true,
      locationId: locationRef.id,
      message: 'Location created successfully'
    };

  } catch (error) {
    functions.logger.error('Error creating location:', error);
    
    // Log failed admin action
    if (request.auth) {
      try {
        await db.collection('adminActions').add({
          userId: request.auth.uid,
          action: 'create',
          entityType: 'location',
          details: { error: error instanceof Error ? error.message : 'Unknown error' },
          timestamp: getTimestamp(),
          success: false
        });
      } catch (logError) {
        functions.logger.error('Failed to log admin action:', logError);
      }
    }

    if (error instanceof functions.https.HttpsError) {
      throw error;
    }
    throw new functions.https.HttpsError('internal', 'Failed to create location');
  }
});

export const adminUpdateLocation = functions.https.onCall(async (request: any) => {
  try {
    const context = request;
    const data = request.data;
    const { locationId, locationData } = data;
    
    // Check authentication
    if (!context.auth) {
      throw new functions.https.HttpsError('unauthenticated', 'User must be authenticated');
    }

    // Check if user has admin privileges
    const userDoc = await db.collection('users').doc(context.auth.uid).get();
    if (!userDoc.exists) {
      throw new functions.https.HttpsError('permission-denied', 'User not found');
    }

    const userData = userDoc.data();
    const hasAdminRole = userData?.role === 'root' || userData?.role === 'admin' || userData?.role === 'volunteer';
    const hasLegacyPermissions = userData?.isAdmin || userData?.isDenLeader || userData?.isCubmaster;
    const hasLocationPermission = userData?.permissions?.includes('location_management') || userData?.permissions?.includes('system_admin');
    
    if (!hasAdminRole && !hasLegacyPermissions && !hasLocationPermission) {
      throw new functions.https.HttpsError('permission-denied', 'Insufficient permissions to update locations');
    }

    if (!locationId) {
      throw new functions.https.HttpsError('invalid-argument', 'Location ID is required');
    }

    // Check if location exists
    const locationRef = db.collection('locations').doc(locationId);
    const locationDoc = await locationRef.get();
    
    if (!locationDoc.exists) {
      throw new functions.https.HttpsError('not-found', 'Location not found');
    }

    // Update location document
    const updateData = {
      ...locationData,
      updatedAt: getTimestamp(),
      updatedBy: context.auth.uid
    };

    await locationRef.update(updateData);

    // Log admin action
    await db.collection('adminActions').add({
      userId: context.auth.uid,
      userEmail: userData?.email || 'unknown',
      action: 'update',
      entityType: 'location',
      entityId: locationId,
      entityName: locationData.name || locationDoc.data()?.name || 'Unknown',
      details: { updateData },
      timestamp: getTimestamp(),
      success: true
    });

    return {
      success: true,
      message: 'Location updated successfully'
    };

  } catch (error) {
    functions.logger.error('Error updating location:', error);
    
    // Log failed admin action
    if (request.auth) {
      try {
        await db.collection('adminActions').add({
          userId: request.auth.uid,
          action: 'update',
          entityType: 'location',
          entityId: request.data?.locationId || 'unknown',
          details: { error: error instanceof Error ? error.message : 'Unknown error' },
          timestamp: getTimestamp(),
          success: false
        });
      } catch (logError) {
        functions.logger.error('Failed to log admin action:', logError);
      }
    }

    if (error instanceof functions.https.HttpsError) {
      throw error;
    }
    throw new functions.https.HttpsError('internal', 'Failed to update location');
  }
});

// Admin Delete User Function (Generation 2)
import { onCall, HttpsError } from 'firebase-functions/v2/https';

const adminDeleteUser = onCall(async (request) => {
  const { data, auth } = request;
  
  try {
    // Check authentication
    if (!auth) {
      throw new HttpsError('unauthenticated', 'User must be authenticated');
    }

    const { userId, reason } = data;
    
    if (!userId) {
      throw new HttpsError('invalid-argument', 'User ID is required');
    }

    // Check if requesting user has admin privileges
    const userDoc = await db.collection('users').doc(auth.uid).get();
    if (!userDoc.exists) {
      throw new HttpsError('permission-denied', 'User not found');
    }

    const userData = userDoc.data();
    const hasAdminRole = userData?.role === 'root' || userData?.role === 'admin';
    const hasLegacyPermissions = userData?.isAdmin || userData?.isCubmaster;
    const hasUserManagementPermission = userData?.permissions?.includes('user_management');
    
    if (!hasAdminRole && !hasLegacyPermissions && !hasUserManagementPermission) {
      throw new HttpsError('permission-denied', 'Insufficient permissions to delete users');
    }

    // Prevent deleting self
    if (userId === auth.uid) {
      throw new HttpsError('invalid-argument', 'Cannot delete your own account');
    }

    // Check if target user exists
    const targetUserDoc = await db.collection('users').doc(userId).get();
    if (!targetUserDoc.exists) {
      throw new HttpsError('not-found', 'User not found');
    }

    const targetUserData = targetUserDoc.data();
    
    // Prevent deleting root users (unless you're also root)
    if (targetUserData?.role === 'root' && userData?.role !== 'root') {
      throw new HttpsError('permission-denied', 'Cannot delete root users');
    }

    // Delete user from Firestore
    await db.collection('users').doc(userId).delete();

    // Delete user from Firebase Auth (requires admin SDK)
    try {
      await admin.auth().deleteUser(userId);
      functions.logger.info(`Firebase Auth user deleted: ${userId}`);
    } catch (authError) {
      functions.logger.warn(`Failed to delete Firebase Auth user ${userId}:`, authError);
      // Continue even if Firebase Auth deletion fails - Firestore deletion is the main concern
    }

    // Log admin action
    await db.collection('adminActions').add({
      userId: auth.uid,
      userEmail: userData?.email || 'unknown',
      action: 'delete',
      entityType: 'user',
      entityId: userId,
      entityName: targetUserData?.displayName || targetUserData?.email || 'Unknown',
      details: { 
        reason: reason || 'No reason provided',
        deletedUserRole: targetUserData?.role,
        deletedUserEmail: targetUserData?.email
      },
      timestamp: getTimestamp(),
      success: true
    });

    return {
      success: true,
      message: 'User deleted successfully'
    };

  } catch (error) {
    functions.logger.error('Error deleting user:', error);
    
    // Log failed admin action
    if (auth) {
      try {
        await db.collection('adminActions').add({
          userId: auth.uid,
          action: 'delete',
          entityType: 'user',
          entityId: data?.userId || 'unknown',
          details: { error: error instanceof Error ? error.message : 'Unknown error' },
          timestamp: getTimestamp(),
          success: false
        });
      } catch (logError) {
        functions.logger.error('Failed to log admin action:', logError);
      }
    }

    if (error instanceof HttpsError) {
      throw error;
    }
    throw new HttpsError('internal', 'Failed to delete user');
  }
});

// Export user approval functions
export { createPendingUser, approveUser, getPendingUsers, getAuditLogs, setAdminClaims, adminDeleteUser };

// Optimized Event Fetching Cloud Function
export const getEventsOptimized = functions.https.onCall(async (data: any, context: functions.https.CallableContext) => {
  try {
    const { 
      limit = 20, 
      offset = 0, 
      category, 
      season, 
      denTags, 
      startDate, 
      endDate,
      includePrivate = false 
    } = data as {
      limit?: number;
      offset?: number;
      category?: string;
      season?: string;
      denTags?: string[];
      startDate?: string;
      endDate?: string;
      includePrivate?: boolean;
    };

    // Check App Check (skip in emulator for testing - events are read-only so less strict)
    if (process.env.FUNCTIONS_EMULATOR !== 'true' && !context.app) {
      // For events, we'll be more permissive since it's read-only data
      // In production, you may want to enable App Check for security
      console.log('âš ï¸ App Check not verified for getEventsOptimized - consider enabling for production');
    }

    // Build optimized query
    let query: any = db.collection('events');
    
    // Add visibility filter unless including private events
    if (!includePrivate) {
      query = query.where('visibility', '==', 'public');
    }
    
    // Add category filter if specified
    if (category && category !== 'all') {
      query = query.where('category', '==', category);
    }
    
    // Add season filter if specified
    if (season && season !== 'all') {
      query = query.where('season', '==', season);
    }
    
    // Add date range filter if specified
    if (startDate) {
      const startDateTime = new Date(startDate);
      query = query.where('startDate', '>=', startDateTime);
    }
    
    if (endDate) {
      const endDateTime = new Date(endDate);
      query = query.where('endDate', '<=', endDateTime);
    }
    
    // Order by start date and apply pagination
    query = query.orderBy('startDate', 'asc').limit(limit).offset(offset);

    const snapshot = await query.get();
    
    // Transform data efficiently
    const events = snapshot.docs.map((doc: admin.firestore.QueryDocumentSnapshot) => {
      const data = doc.data();
      return {
        id: doc.id,
        title: data.title,
        description: data.description,
        startDate: data.startDate?.toDate?.()?.toISOString() || data.startDate,
        endDate: data.endDate?.toDate?.()?.toISOString() || data.endDate,
        startTime: data.startTime,
        endTime: data.endTime,
        location: data.location,
        locationId: data.locationId,
        category: data.category,
        season: data.season,
        seasonId: data.seasonId,
        denTags: data.denTags || [],
        maxCapacity: data.maxCapacity,
        currentRSVPs: data.currentRSVPs || 0,
        visibility: data.visibility,
        status: data.status,
        createdAt: data.createdAt?.toDate?.()?.toISOString() || data.createdAt,
        updatedAt: data.updatedAt?.toDate?.()?.toISOString() || data.updatedAt
      };
    });

    // Get total count for pagination (separate query for efficiency)
    let countQuery: any = db.collection('events');
    if (!includePrivate) {
      countQuery = countQuery.where('visibility', '==', 'public');
    }
    if (category && category !== 'all') {
      countQuery = countQuery.where('category', '==', category);
    }
    if (season && season !== 'all') {
      countQuery = countQuery.where('season', '==', season);
    }
    
    const countSnapshot = await countQuery.get();
    const totalCount = countSnapshot.size;

    return {
      success: true,
      events,
      pagination: {
        limit,
        offset,
        totalCount,
        hasMore: offset + limit < totalCount
      },
      filters: {
        category,
        season,
        denTags,
        startDate,
        endDate
      }
    };

  } catch (error) {
    console.error('Error fetching events:', error);
    
    if (error instanceof functions.https.HttpsError) {
      throw error;
    }
    
    throw new functions.https.HttpsError('internal', 'Failed to fetch events');
  }
});

// Event Search Cloud Function with Full-Text Search
export const searchEvents = functions.https.onCall(async (data: any, context: functions.https.CallableContext) => {
  try {
    const { 
      query: searchQuery, 
      limit = 10,
      category,
      season 
    } = data as {
      query: string;
      limit?: number;
      category?: string;
      season?: string;
    };

    // Check App Check (skip in emulator and development for testing)
    if (process.env.FUNCTIONS_EMULATOR !== 'true' && process.env.NODE_ENV !== 'development' && !context.app) {
      throw new functions.https.HttpsError('unauthenticated', 'App Check required');
    }

    if (!searchQuery || searchQuery.trim().length < 2) {
      throw new functions.https.HttpsError('invalid-argument', 'Search query must be at least 2 characters');
    }

    // Build search query
    let query = db.collection('events')
      .where('visibility', '==', 'public')
      .where('status', '==', 'active');

    // Add filters
    if (category && category !== 'all') {
      query = query.where('category', '==', category);
    }
    
    if (season && season !== 'all') {
      query = query.where('season', '==', season);
    }

    const snapshot = await query.get();
    
    // Client-side text search (Firestore doesn't have full-text search)
    const searchTerms = searchQuery.toLowerCase().split(' ').filter(term => term.length > 0);
    
    const matchingEvents = snapshot.docs
      .map(doc => {
        const data = doc.data();
        
        // Calculate relevance score
        let score = 0;
        searchTerms.forEach(term => {
          if (data.title.toLowerCase().includes(term)) score += 10;
          if (data.description.toLowerCase().includes(term)) score += 5;
          if (data.location.toLowerCase().includes(term)) score += 3;
          if (data.denTags?.some((tag: string) => tag.toLowerCase().includes(term))) score += 2;
        });
        
        return {
          id: doc.id,
          ...data,
          startDate: data.startDate?.toDate?.()?.toISOString() || data.startDate,
          endDate: data.endDate?.toDate?.()?.toISOString() || data.endDate,
          createdAt: data.createdAt?.toDate?.()?.toISOString() || data.createdAt,
          updatedAt: data.updatedAt?.toDate?.()?.toISOString() || data.updatedAt,
          relevanceScore: score
        };
      })
      .filter(event => event.relevanceScore > 0)
      .sort((a, b) => b.relevanceScore - a.relevanceScore)
      .slice(0, limit);

    return {
      success: true,
      events: matchingEvents,
      query: searchQuery,
      totalResults: matchingEvents.length
    };

  } catch (error) {
    console.error('Error searching events:', error);
    
    if (error instanceof functions.https.HttpsError) {
      throw error;
    }
    
    throw new functions.https.HttpsError('internal', 'Failed to search events');
  }
});

// Export testAuth function
export { testAuth };
